#!/usr/bin/env ruby
#
# @version 1.2.1
# @author Franklin P. Strube <franklin.strube@gmail.com>
# @copyright 2014 Franklin P. Strube
#
#: Usage: frak <command> [option=value option=value ...]
#:
#: Commands
#:   init          Initialize the current directory for frak deployment
#:   console       Connect to the remote server via SSH
#:   diff          Show differences between local and remote files
#:   pull          Download the remote file(s)
#:   push          Deploy website via the method specified in the config
#:   backups:list  List any backups found on the server
#:   backups:purge Purge all backups
#:   --help        Display this help message
#:   --version     Display the current version of frak, also checks for upgrades
#:
#: Options
#:   label         a short name for the project, used by webhooks
#:   env           load the specified environment into the config
#:   method        currently only supports rsync
#:   command       execute a command on the remote server
#:   path          defaults to current directory
#:   remote_path   override what is read from .frak file
#:   rsync_path    override the rsync-path read from .frak file (if present)
#:   ignore        ignore certain files or folders when deploying
#:   webhook_url   URL for a webhook which will receive information about the code pushed via frak
#:   --no-color    Disable ANSI colors in diff output.
#:
#: Examples
#:
#:   Execute a command on your deployment server:
#:     frak console command="vi index.html"
#:
#:   Compare specific files before deploying:
#:     frak diff path="*.html"
#:
#:   Deploy files but exclude certain paths:
#:     frak ignore="logs uploads"

require 'yaml'
require 'digest'
require 'time'
require 'shellwords'

# Colors
module ANSI
  CLEAR = "\033[0m"
  BOLD = "\033[1m"
  UNDERLINE = "\033[4m"

  BLACK = "\033[30m"
  RED = "\033[31m"
  GREEN = "\033[32m"
  YELLOW = "\033[33m"
  BLUE = "\033[34m"
  MAGENTA = "\033[35m"
  CYAN = "\033[36m"
  WHITE = "\033[37m"
end

##
# The main routine of the program. Typical execution is:
#   1. Parse arguments
#   2. Load configuration
#   3. Execute proper command

def main
  # Process the commandline arguments
  $command, $options = parse_command

  #Track changes for posting to webhook
  $file_changes = ""
  $diff_name = ""
  $diff_contents = ""

  # Check for updates
  auto_update

  begin

    if not $command == "init"
      # Load the config, but commandline options take precedence.
      $options.merge!(config) { |k,a,b| a }

      # Load special production config, but commandline options take precedence.
      if $options[:env]
        if config[$options[:env].to_sym].nil?
          raise %Q:Missing configuration for environment "#{$options[:env]}"!:
        end
        $options.merge!(config[$options[:env].to_sym]) { |k,a,b| a }
      end
    end

    # Convert all keys in options to symbols
    $options = Hash[$options.map { |k, v| [k.to_sym, v] }]

    execute
  rescue Exception => e
    say "#{ANSI::RED}#{e.message}#{ANSI::CLEAR}"
    debug e.backtrace.join("\n"), ANSI::CLEAR
  end
end

def agree(prompt)
  printf("#{prompt.chomp} ")
  answer = $stdin.gets.chomp

  return %w(y yes).include?(answer.downcase)
end

##
# Alias for puts

def say(something)
  puts something
end

##
# Debug output

def debug(something, color=ANSI::BLUE)
  say "#{color}#{something}#{ANSI::CLEAR}" if $options[:debug]
end

##
# Outputs the usage / help information for this executable.

def usage
  File.open __FILE__ do |f|
    f.each_line.grep(/^#:/) do |l|
      say l[2..-1]
    end
  end
end

##
# Outputs the version information for the frak tool.

def version
  File.open __FILE__ do |f|
    f.each_line.grep(/^# @version/) do |l|
      return l[11..-2]
    end
  end
end

##
# Parse command and options

def parse_command
  arguments = ARGV.clone
  options = {backup_path: ".backups", backup_retention: "30 days", colorize: true, paginate: true}
  command = "push"
  while arguments.length > 0
    if arguments[0] =~ /=/ then
      key, value = arguments[0].split '='
      options[key.to_sym] = value
    elsif arguments[0] == "--no-color" then
      options[:colorize] = false
    else
      command = arguments[0]
    end
    arguments.shift
  end

  return [command, options]
end

##
# Read YAML from .frak configuration file

def config
  if File.exists? frakfile
    Hash[YAML.load_file(frakfile).map { |k, v| [k.to_sym, v] }]
  else
    {}
  end
end

##
# Find a .frak configuration file in the directories
# above.

def frakfile
  frakfile = ".frak"
  while not File.exists? frakfile
    break if File.expand_path(frakfile) == '/.frak'
    frakfile = "../#{frakfile}"
  end

  if not File.exists? frakfile
    raise "Frak! No configuration file found! Please run 'frak init' in your project folder."
  end

  return File.expand_path frakfile
end

##
# Which diff command or utility to use
def diff_command
  if $options[:diff]
    return $options[:diff]
  else
    return "diff -Naurp"
  end
end

##
# Determine what is the local_path to be deployed

def rsync_files
  # if path= is defined
  if $options[:path]
    paths = $options[:path].split.map { |p| File.expand_path p }
  else
    paths = [Dir.pwd]
  end

  # expand any wildcards
  paths.map! { |p| Dir.glob(p) }
  paths.flatten!

  # make paths relative to .frak file
  paths.map! { |p| p.sub File.dirname(frakfile), "" }

  return paths
end

##
# Generate a filter for rsync

def rsync_filter
  filter = [".frak*", ".git*", ".svn*", ".tags*", "Capfile", "Gemfile*", "Vagrantfile*"]

  # include filters via commandline
  if $options[:ignore]
    filter = filter + $options[:ignore].split
  end

  filter.map! { |e| "--filter='- #{e}'" }

  if File.exists? "#{File.dirname frakfile}/.frakignore" then
    filter.push "--filter='.e .frakignore'"
  end

  filter.join ' '
end

##
# List any backups found on the server

def backups_list
  system %Q:ssh #{$options[:server]} 'ls #{$options[:remote_path]}/#{$options[:backup_path]}':
end

##
# Purge any outdated backups

def backups_purge
  begin
    date = parse_date "#{$options[:backup_retention]} ago"
  rescue
    raise "Invalid retention date! #{$options[:backup_retention]}"
  end
  say "#{ANSI::YELLOW}Purging old backups before #{date.strftime "%c"}.#{ANSI::CLEAR}"

  system %Q:ssh #{$options[:server]} 'cd #{$options[:remote_path]}; for x in `ls #{$options[:backup_path]}`; do [ $x -lt "#{date.strftime '%Y%m%d%H%M%S'}" ] && rm -rf #{$options[:backup_path]}/$x && echo Backup $x removed; done':
end

##
# Create a patch of the latest backup

def backups_patch
  return unless $backup_path

  hash = Digest::SHA2.new.update(Time.new.strftime("%Y%m%d%H%M%S")).to_s
  patch_command = "" +
    "find . -type f | " +
    "grep -v #{hash}.patch | " +
    "cut -c3- | " +
    "xargs -I {} diff -u -x #{hash}.patch --label a/{} --label b/{} ./{} #{$options[:remote_path]}/{}"
  say "#{ANSI::YELLOW}Generating patch file #{hash}.patch.#{ANSI::CLEAR}"
  system %Q:ssh #{$options[:server]} 'cd #{$options[:remote_path]}/#{$backup_path} 2>/dev/null || exit; #{patch_command} >> #{$options[:remote_path]}/#{$backup_path}/#{hash}.patch':
  $diff_contents = `ssh #{$options[:server]} 'cat #{$options[:remote_path]}/#{$backup_path}/#{hash}.patch'`
  $diff_name = ($options[:label].nil? ? hash : $options[:label]) + "/#{$backup_path}/#{hash}.patch"
end

##
# Parse a date from a string of the format "x <days|weeks|months|years> [ago]"

def parse_date(string)
  parts = string.split

  if parts[1][0..5] == "second"
    seconds = parts[0].to_f
  elsif parts[1][0..5] == "minute"
    seconds = parts[0].to_f * 60
  elsif parts[1][0..3] == "hour"
    seconds = parts[0].to_f * 60 * 60
  elsif parts[1][0..2] == "day"
    seconds = parts[0].to_f * 60 * 60 * 24
  elsif parts[1][0..3] == "week"
    seconds = parts[0].to_f * 60 * 60 * 24 * 7
  elsif parts[1][0..4] == "month"
    seconds = parts[0].to_f * 60 * 60 * 24 * 30
  elsif parts[1][0..3] == "year"
    seconds = parts[0].to_f * 60 * 60 * 24 * 365
  end

  if parts[2] == "ago"
    return Time.now - seconds
  else
    return Time.now + seconds
  end
end

##
# Generate the entire rsync command. Uses rsync's --files-from
# parameter to deploy multiple paths at once.

def rsync_command(options = nil)
  if rsync_files.join.length > 0
    rsync = "echo \"#{rsync_files.join("\n")}\" | "
  end

  # Flip the source and destination if this is a pull command
  if $command == "pull"
    # trailing slashes are important for pull
    source = "#{$options[:server]}:#{$options[:remote_path]}/"
    destination = "#{File.dirname frakfile}/"
  else
    source = "#{File.dirname frakfile}/"
    destination = "#{$options[:server]}:#{$options[:remote_path]}"
  end

  # Figure out backup options
  if !$options[:backup_path].nil? && $options[:backup_path]
    backup = ["--exclude \"#{$options[:backup_path]}\""]
    if not $command == "pull"
      # keep the same backup path for all rsync_commands
      $backup_path = "#{$options[:backup_path]}/#{Time.new.strftime("%Y%m%d%H%M%S")}" if $backup_path.nil?
      backup.push "--backup --backup-dir \"#{$backup_path}\""
    end
    backup = "#{backup.join ' '} "
  end

  rsync = "#{rsync}rsync " +
    "--archive --no-group --no-owner --no-perms --no-times --human-readable " +
    "--compress --checksum --itemize-changes --recursive --delete " +
    ($options[:rsync_path].nil? ? "" : "--rsync-path=\"#{$options[:rsync_path]}\" ") +
    "#{rsync_filter} " +
    backup +
    "#{options} " +
    (rsync_files.join.length > 0 ? "--files-from=- --relative " : "") +
    "'#{source}' #{destination}"
end

##
# Execute the appropriate command

def execute
  case $command
    when "init"
      system "touch .frak .frakignore && $EDITOR .frak"

    when "backups:list"
      backups_list

    when "backups:purge"
      backups_purge

    when "console"
      system "ssh #{$options[:server]} #{$options[:command]}"

    when "push", "pull"
      # generate a dry-run command
      command = rsync_command "--dry-run"

      debug command

      # run it from the root directory where .frak file is found
      Dir.chdir File.dirname frakfile do
        $file_changes = `#{command}`
        puts $file_changes
      end

      begin
        # prompt for continuance
        proceed = agree("#{ANSI::YELLOW}The above actions will be taken. Continue? (This cannot be undone): #{ANSI::CLEAR}")
        if proceed
          command = rsync_command
          # run in the directory that .frak file is found
          Dir.chdir File.dirname frakfile do
            system command
            backups_patch
            backups_purge
            if $options[:after]
              say "#{ANSI::YELLOW}Executing commands on remote server.#{ANSI::CLEAR}"
              system "ssh #{$options[:server]} '#{$options[:after]}'"
            end
          end
          say "#{ANSI::GREEN}Deployment complete.#{ANSI::CLEAR}"
          if $options[:webhook_url] && $command == 'push'
            post_webhook
          end
        else
          say "#{ANSI::RED}Deployment cancelled by user.#{ANSI::CLEAR}"
        end
      # rescue handles ctrl+c
      rescue Interrupt
        say "\n#{ANSI::RED}Deployment cancelled by user.#{ANSI::CLEAR}"
      end

    when "diff"
      # show differences between server and local
      changes = ""
      Dir.chdir File.dirname frakfile do
        changes = `#{rsync_command "--dry-run"}`.lines.collect do |change|
          change.chomp.split(' ', 2)
        end.select do |change|
          action, file = change
          file[-1] != '/'
        end
      end

      proceed = changes.count < 50 || agree("#{ANSI::YELLOW}#{changes.count} file(s) will be compared. Continue?#{ANSI::CLEAR}")

      if proceed
        Dir.chdir File.dirname frakfile do
          # build a single diff command for all changes
          files = changes.select { |change| change[0] != '*deleting' }.collect do |change|
            action, file = change

            case action
              when 'cL+++++++'
                file.split(' -> ')[0]
              else
                file
            end
          end
          tar = ['tar', 'cz'].concat(files.sort)

          diffs = changes.sort {|a,b| a[1] <=> b[1] }.collect do |change|
            action, file = change

            git_diff_header = ["diff --git a/#{file} b/#{file}"]

            diff = ""
            case action
              when '*deleting'
                git_diff_header.push("deleted file mode 100644")
                git_diff_header.push("index 0000000..0000000")
                diff = "#{diff_command} --label=#{file} --label=/dev/null #{file} /dev/null"
              when '<f+++++++'
                git_diff_header.push("new file mode #{sprintf '%o', File.stat(file).mode}")
                git_diff_header.push("index 0000000..0000000")
                diff = "#{diff_command} --label=/dev/null --label=#{file} /dev/null <(tar xzOf $tarball --warning=no-unknown-keyword #{file} || cat /dev/null)"
              when 'cL+++++++'
                file, target = file.split(' -> ')
                git_diff_header.push("new file mode 120000")
                git_diff_header.push("index 0000000..0000000")
                diff = "#{diff_command} --label=/dev/null --label=#{file} /dev/null <(printf %s #{target})"
              else
                git_diff_header.push("index 0000000..0000000 #{sprintf '%o', File.stat(file).mode}")
                diff = "#{diff_command} --label=#{file} --label=#{file} #{file} <(tar xzOf $tarball --warning=no-unknown-keyword #{file} || cat /dev/null)"
            end


            %Q[printf "%s\\n" #{Shellwords.shellescape git_diff_header.join("\n")}; #{diff}]
          end

          # colorize the output so it is pretty
          colorize = '| sed -l ' + [
            # additions
            %Q[-e 's/^\\(+[^+].*\\)/#{ANSI::GREEN}\\1#{ANSI::CLEAR}/'],
            %Q[-e 's/^\\(+\\)$/#{ANSI::GREEN}\\1#{ANSI::CLEAR}/'],
            # deletions
            %Q[-e 's/^\\(-[^-].*\\)/#{ANSI::RED}\\1#{ANSI::CLEAR}/'],
            %Q[-e 's/^\\(-\\)$/#{ANSI::RED}\\1#{ANSI::CLEAR}/'],
            # markers
            %Q[-e 's/^\\(@@ -[0-9][0-9]*,[0-9][0-9]* +[0-9][0-9]*,[0-9][0-9]* .*@@\\)/#{ANSI::BLUE}\\1#{ANSI::CLEAR}/'],
            %Q[-e 's/^\\(@@ -[0-9][0-9]*,[0-9][0-9]* +[0-9][0-9]* .*@@\\)/#{ANSI::BLUE}\\1#{ANSI::CLEAR}/'],
            %Q[-e 's/^\\(@@ -[0-9][0-9]* +[0-9][0-9]*,[0-9][0-9]* .*@@\\)/#{ANSI::BLUE}\\1#{ANSI::CLEAR}/']
          ].join(' ')

          # paginate the output if it is long
          pager = $options[:paginate] ? %Q[| #{ENV['PAGER'] || "less"}] : ""

          if diffs.length > 0
            debug %Q(#{Shellwords.join tar} | #{Shellwords.join ['ssh', $options[:server], "tarball=$(mktemp /tmp/frak-diff-tarball.XXXXXXXX); cat > $tarball; cd #{$options[:remote_path]}; #{diffs.join ";"}; rm $tarball"]} #{colorize if $options[:colorize]} #{pager if $options[:paginate]})
            system %Q(#{Shellwords.join tar} | #{Shellwords.join ['ssh', $options[:server], "tarball=$(mktemp /tmp/frak-diff-tarball.XXXXXXXX); cat > $tarball; cd #{$options[:remote_path]}; #{diffs.join ";"}; rm $tarball"]} #{colorize if $options[:colorize]} #{pager if $options[:paginate]})
          end
        end
      end

    when "--help"
      usage

    when "--version"
      say version

    else
      usage

  end
end

def auto_update
  require 'open-uri'

  begin
    open("https://raw.github.com/fstrube/frak/master/bin/frak") do |r|
      r.each_line do |line|
        if line[0..9] == "# @version"
          new_version = line[11..-2].to_s
          if new_version != version
            upgrade = agree("#{ANSI::YELLOW}Version #{new_version} is now available. You are currently running version #{version}. Would you like to upgrade? (y/n) #{ANSI::CLEAR}")
            if upgrade
              File.open(__FILE__, 'w') do |file|
                r.pos = 0
                file.write(r.read)
              end
              say "Upgraded to version #{new_version}."
              system Shellwords.join([$0] + ARGV) unless $command == "--version"
              exit
            end
          end
        end
      end
    end
  rescue
    say "#{ANSI::YELLOW}WARNING: Unable to check for new version of frak. Please check your internet connection.#{ANSI::CLEAR}"
  end
end

##
# Post to a configured webhook

def post_webhook
  require 'net/http'

  begin
    # Post a message to the webhook containing information on the push
    url = URI.parse($options[:webhook_url])
    params = {
        'username' => ENV['USER'],
        'label' => ($options[:label].nil? ? '' : $options[:label]),
        'environment' => ($options[:env].nil? ? 'default' : $options[:env]),
        'server' => $options[:server],
        'diff_file' => $diff_name,
        'diff_contents' => $diff_contents,
        'files_changed' => $file_changes,
      }
    request = Net::HTTP::Post.new(url.request_uri)
    request.form_data = params
    response = Net::HTTP.start(url.hostname, url.port, :use_ssl => url.scheme == 'https' ) do |http|
      http.request(request)
    end

    debug "POST #{url} #{params}"
    if response.code.match(/2../)
      say "#{ANSI::GREEN}Successfully posted to webhook #{$options[:webhook_url]}.#{ANSI::CLEAR}"
    else
      say "#{ANSI::YELLOW}Posting to webhook failed #{$options[:webhook_url]}.#{ANSI::CLEAR}"
      debug response.body, ANSI::RED
    end
  rescue Exception => e
    say "#{ANSI::YELLOW}WARNING: Unable to post to configured webhook. Please check your internet connection.#{ANSI::CLEAR}"
    debug e.message, ANSI::RED
    debug e.backtrace.join("\n"), ANSI::YELLOW
  end
end

if __FILE__ == $0
  main
end
